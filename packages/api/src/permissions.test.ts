import { describe, it, expect, beforeAll, afterAll } from "bun:test";
import type { Server } from "bun";

// Test configuration
const TEST_API_URL = "http://localhost:3001";
const TEST_WS_URL = "ws://localhost:8001";

// Test tokens (these would normally be generated by the auth flow)
const OWNER_TOKEN = "test-owner-token";
const OTHER_USER_TOKEN = "test-other-token";

describe("Permission Model Tests", () => {
  let server: Server;

  beforeAll(async () => {
    // Start test server if needed
    // In real implementation, this would spin up the API with test Redis
  });

  afterAll(async () => {
    // Cleanup
    if (server) {
      server.stop();
    }
  });

  describe("Channel Type Detection", () => {
    it("should identify public.* channels as publicly readable", () => {
      const publicChannels = [
        "public.lobby",
        "public.access",
        "public.alerts",
        "public.chat.general"
      ];
      
      for (const channel of publicChannels) {
        expect(channel.startsWith("public.")).toBe(true);
      }
    });

    it("should identify agent.* channels as agent-owned", () => {
      const agentChannels = [
        "agent.alice.updates",
        "agent.bob.data.sensor1",
        "agent.testuser.notifications"
      ];
      
      for (const channel of agentChannels) {
        const parts = channel.split(".");
        expect(parts[0]).toBe("agent");
        expect(parts.length).toBeGreaterThanOrEqual(3);
        expect(parts[1]).toBeTruthy(); // owner name
      }
    });

    it("should identify system.* channels as system-only", () => {
      const systemChannels = [
        "system.timer.second",
        "system.timer.minute",
        "system.timer.week.monday",
        "system.timer.monthly.january"
      ];
      
      for (const channel of systemChannels) {
        expect(channel.startsWith("system.")).toBe(true);
      }
    });
  });

  describe("Write Permissions", () => {
    it("should allow owner to publish to their own agent.* channel", async () => {
      const channel = "agent.owner.data";
      const payload = { message: "test" };
      
      // This should succeed
      const response = await fetch(`${TEST_API_URL}/api/publish`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OWNER_TOKEN}` // token for "owner" user
        },
        body: JSON.stringify({ channel, payload })
      });
      
      expect(response.status).toBe(200);
    });

    it("should deny non-owner from publishing to agent.* channel", async () => {
      const channel = "agent.owner.data";
      const payload = { message: "test" };
      
      // This should fail with 403
      const response = await fetch(`${TEST_API_URL}/api/publish`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OTHER_USER_TOKEN}` // token for different user
        },
        body: JSON.stringify({ channel, payload })
      });
      
      expect(response.status).toBe(403);
      const body = await response.json();
      expect(body.error).toContain("only the channel owner can publish");
    });

    it("should deny anyone from publishing to system.* channels", async () => {
      const systemChannels = [
        "system.timer.second",
        "system.timer.minute",
        "system.timer.day"
      ];
      
      for (const channel of systemChannels) {
        const response = await fetch(`${TEST_API_URL}/api/publish`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${OWNER_TOKEN}`
          },
          body: JSON.stringify({ channel, payload: { test: true } })
        });
        
        expect(response.status).toBe(403);
        const body = await response.json();
        expect(body.error).toContain("cannot publish to system channels");
      }
    });

    it("should allow anyone to publish to public.* channels", async () => {
      const publicChannels = [
        "public.lobby",
        "public.access",
        "public.alerts"
      ];
      
      for (const channel of publicChannels) {
        const response = await fetch(`${TEST_API_URL}/api/publish`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${OTHER_USER_TOKEN}`
          },
          body: JSON.stringify({ channel, payload: { test: true } })
        });
        
        expect(response.status).toBe(200);
      }
    });

    it("should deny non-owner even if agent channel is not locked", async () => {
      // First, ensure channel exists and is NOT locked
      const channel = "agent.owner.unlocked";
      
      // Try to publish as non-owner
      const response = await fetch(`${TEST_API_URL}/api/publish`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OTHER_USER_TOKEN}`
        },
        body: JSON.stringify({ channel, payload: { test: true } })
      });
      
      // Should still be denied - lock status doesn't affect write permissions
      expect(response.status).toBe(403);
    });
  });

  describe("Read/Subscribe Permissions", () => {
    it("should allow anyone to subscribe to unlocked agent.* channels", async () => {
      const channel = "agent.owner.public";
      
      // Subscribe proxy should allow
      const response = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel, user: "any-user" })
      });
      
      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body.result).toBeDefined();
    });

    it("should deny non-permitted users from subscribing to locked agent.* channels", async () => {
      // First, lock the channel
      await fetch(`${TEST_API_URL}/api/lock`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OWNER_TOKEN}`
        },
        body: JSON.stringify({ channel: "agent.owner.private" })
      });
      
      // Try to subscribe as non-permitted user
      const response = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel: "agent.owner.private", user: "unauthorized-user" })
      });
      
      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body.error).toBeDefined();
      expect(body.error.code).toBe(403);
    });

    it("should allow owner to subscribe to their own locked channels", async () => {
      const response = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel: "agent.owner.private", user: "owner" })
      });
      
      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body.result).toBeDefined();
    });

    it("should allow permitted users to subscribe to locked channels", async () => {
      // First, grant permission
      await fetch(`${TEST_API_URL}/api/grant`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OWNER_TOKEN}`
        },
        body: JSON.stringify({ target: "friend", channel: "agent.owner.private" })
      });
      
      // Try to subscribe as permitted user
      const response = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel: "agent.owner.private", user: "friend" })
      });
      
      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body.result).toBeDefined();
    });
  });

  describe("Permission Separation", () => {
    it("should maintain separate read and write permissions", async () => {
      const channel = "agent.owner.test";
      
      // Lock the channel
      await fetch(`${TEST_API_URL}/api/lock`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OWNER_TOKEN}`
        },
        body: JSON.stringify({ channel })
      });
      
      // Grant read permission to another user
      await fetch(`${TEST_API_URL}/api/grant`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OWNER_TOKEN}`
        },
        body: JSON.stringify({ target: "friend", channel })
      });
      
      // Friend should be able to subscribe (read)
      const subResponse = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel, user: "friend" })
      });
      
      expect(subResponse.status).toBe(200);
      const subBody = await subResponse.json();
      expect(subBody.result).toBeDefined();
      
      // But friend should NOT be able to publish (write)
      const pubResponse = await fetch(`${TEST_API_URL}/api/publish`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer test-friend-token`
        },
        body: JSON.stringify({ channel, payload: { test: true } })
      });
      
      expect(pubResponse.status).toBe(403);
    });

    it("should allow public read on all channel types", async () => {
      const channels = [
        "public.lobby",
        "system.timer.minute",
        "agent.owner.data"
      ];
      
      for (const channel of channels) {
        const response = await fetch(`${TEST_API_URL}/proxy/subscribe`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ channel, user: "anonymous" })
        });
        
        // System and public should always allow
        // Agent channels might be locked, but we test that separately
        if (channel.startsWith("public.") || channel.startsWith("system.")) {
          expect(response.status).toBe(200);
          const body = await response.json();
          expect(body.result).toBeDefined();
        }
      }
    });
  });
});

describe("Channel Parsing", () => {
  it("should correctly parse agent channel parts", () => {
    const testCases = [
      { channel: "agent.alice.updates", owner: "alice", topic: "updates" },
      { channel: "agent.bob.data.sensor1", owner: "bob", topic: "data.sensor1" },
      { channel: "agent.user123.notifications.email", owner: "user123", topic: "notifications.email" }
    ];
    
    for (const { channel, owner, topic } of testCases) {
      const parts = channel.split(".");
      expect(parts[0]).toBe("agent");
      expect(parts[1]).toBe(owner);
      expect(parts.slice(2).join(".")).toBe(topic);
    }
  });

  it("should reject invalid channel formats", () => {
    const invalidChannels = [
      "agent",              // too short
      "agent.",             // no owner
      "agent.owner",        // no topic
      "random.channel",     // wrong prefix
      "",                   // empty
      "agent..topic",       // empty owner
    ];
    
    for (const channel of invalidChannels) {
      const parts = channel.split(".");
      // Should not be a valid agent channel
      if (parts.length >= 3 && parts[0] === "agent") {
        // Valid format but might have empty parts
        expect(parts[1]).toBeTruthy();
      } else {
        expect(parts.length < 3 || parts[0] !== "agent").toBe(true);
      }
    }
  });
});
